/**
 * DevExtreme (bundles/__internal/scheduler/workspaces/view_model/m_time_panel_data_generator.js)
 * Version: 22.2.13
 * Build date: Fri Aug 09 2024
 *
 * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TimePanelDataGenerator = void 0;
var _date = _interopRequireDefault(require("../../../../core/utils/date"));
var _base = require("../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base");
var _week = require("../../../../renovation/ui/scheduler/view_model/to_test/views/utils/week");
var _utils = require("../../../../renovation/ui/scheduler/workspaces/utils");
var _math = require("../../../core/utils/math");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    }
}

function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest()
}

function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) {
        return
    }
    if ("string" === typeof o) {
        return _arrayLikeToArray(o, minLen)
    }
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if ("Object" === n && o.constructor) {
        n = o.constructor.name
    }
    if ("Map" === n || "Set" === n) {
        return Array.from(o)
    }
    if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
        return _arrayLikeToArray(o, minLen)
    }
}

function _arrayLikeToArray(arr, len) {
    if (null == len || len > arr.length) {
        len = arr.length
    }
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i]
    }
    return arr2
}

function _iterableToArrayLimit(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
        var _s, _e, _x, _r, _arr = [],
            _n = !0,
            _d = !1;
        try {
            if (_x = (_i = _i.call(arr)).next, 0 === i) {
                if (Object(_i) !== _i) {
                    return
                }
                _n = !1
            } else {
                for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) {}
            }
        } catch (err) {
            _d = !0, _e = err
        } finally {
            try {
                if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) {
                    return
                }
            } finally {
                if (_d) {
                    throw _e
                }
            }
        }
        return _arr
    }
}

function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) {
        return arr
    }
}

function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key]
                }
            }
        }
        return target
    };
    return _extends.apply(this, arguments)
}
var __rest = (void 0, function(s, e) {
    var t = {};
    for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) {
            t[p] = s[p]
        }
    }
    if (null != s && "function" === typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) {
                t[p[i]] = s[p[i]]
            }
        }
    }
    return t
});
var toMs = _date.default.dateToMilliseconds;
var TimePanelDataGenerator = function() {
    function TimePanelDataGenerator(_viewDataGenerator) {
        this._viewDataGenerator = _viewDataGenerator
    }
    var _proto = TimePanelDataGenerator.prototype;
    _proto.getCompleteTimePanelMap = function(options, completeViewDataMap) {
        var _this = this;
        var startViewDate = options.startViewDate,
            cellDuration = options.cellDuration,
            startDayHour = options.startDayHour,
            isVerticalGrouping = options.isVerticalGrouping,
            intervalCount = options.intervalCount,
            currentDate = options.currentDate,
            viewType = options.viewType,
            hoursInterval = options.hoursInterval,
            endDayHour = options.endDayHour,
            viewOffset = options.viewOffset,
            today = options.today,
            showCurrentTimeIndicator = options.showCurrentTimeIndicator;
        var rowsCount = completeViewDataMap.length - 1;
        var realEndViewDate = completeViewDataMap[rowsCount][completeViewDataMap[rowsCount].length - 1].endDate;
        var rowCountInGroup = this._viewDataGenerator.getRowCount({
            intervalCount: intervalCount,
            currentDate: currentDate,
            viewType: viewType,
            hoursInterval: hoursInterval,
            startDayHour: startDayHour,
            endDayHour: endDayHour
        });
        var cellCountInGroupRow = this._viewDataGenerator.getCellCount({
            intervalCount: intervalCount,
            currentDate: currentDate,
            viewType: viewType,
            hoursInterval: hoursInterval,
            startDayHour: startDayHour,
            endDayHour: endDayHour
        });
        var allDayRowsCount = 0;
        var usualCellIndex = 0;
        return completeViewDataMap.map((function(row, index) {
            var _a = row[0],
                allDay = _a.allDay,
                startDate = _a.startDate,
                groups = (_a.endDate, _a.groups),
                groupIndex = _a.groupIndex,
                isFirstGroupCell = _a.isFirstGroupCell,
                isLastGroupCell = _a.isLastGroupCell,
                cellIndex = _a.index,
                restCellProps = __rest(_a, ["allDay", "startDate", "endDate", "groups", "groupIndex", "isFirstGroupCell", "isLastGroupCell", "index"]);
            var highlighted = allDay ? false : _this.isTimeCellShouldBeHighlighted(today, viewOffset, {
                startViewDate: startViewDate,
                realEndViewDate: realEndViewDate,
                showCurrentTimeIndicator: showCurrentTimeIndicator
            }, {
                date: startDate,
                index: usualCellIndex,
                duration: Math.round(cellDuration),
                isFirst: 0 === usualCellIndex,
                isLast: _this.isLastCellInGroup(completeViewDataMap, index)
            });
            if (allDay) {
                allDayRowsCount += 1;
                usualCellIndex = 0
            } else {
                usualCellIndex += 1
            }
            var timeIndex = (index - allDayRowsCount) % rowCountInGroup;
            return _extends(_extends({}, restCellProps), {
                startDate: startDate,
                allDay: allDay,
                highlighted: highlighted,
                text: (0, _week.getTimePanelCellText)(timeIndex, startDate, startViewDate, cellDuration, startDayHour),
                groups: isVerticalGrouping ? groups : void 0,
                groupIndex: isVerticalGrouping ? groupIndex : void 0,
                isFirstGroupCell: isVerticalGrouping && isFirstGroupCell,
                isLastGroupCell: isVerticalGrouping && isLastGroupCell,
                index: Math.floor(cellIndex / cellCountInGroupRow)
            })
        }))
    };
    _proto.generateTimePanelData = function(completeTimePanelMap, options) {
        var startRowIndex = options.startRowIndex,
            rowCount = options.rowCount,
            topVirtualRowHeight = options.topVirtualRowHeight,
            bottomVirtualRowHeight = options.bottomVirtualRowHeight,
            isGroupedAllDayPanel = options.isGroupedAllDayPanel,
            isVerticalGrouping = options.isVerticalGrouping,
            isAllDayPanelVisible = options.isAllDayPanelVisible;
        var indexDifference = isVerticalGrouping || !isAllDayPanelVisible ? 0 : 1;
        var correctedStartRowIndex = startRowIndex + indexDifference;
        var displayedRowCount = (0, _base.getDisplayedRowCount)(rowCount, completeTimePanelMap);
        var timePanelMap = completeTimePanelMap.slice(correctedStartRowIndex, correctedStartRowIndex + displayedRowCount);
        var timePanelData = {
            topVirtualRowHeight: topVirtualRowHeight,
            bottomVirtualRowHeight: bottomVirtualRowHeight,
            isGroupedAllDayPanel: isGroupedAllDayPanel
        };
        var _this$_generateTimePa = this._generateTimePanelDataFromMap(timePanelMap, isVerticalGrouping),
            groupedData = _this$_generateTimePa.previousGroupedData;
        timePanelData.groupedData = groupedData;
        return timePanelData
    };
    _proto._generateTimePanelDataFromMap = function(timePanelMap, isVerticalGrouping) {
        return timePanelMap.reduce((function(_ref, cellData) {
            var previousGroupIndex = _ref.previousGroupIndex,
                previousGroupedData = _ref.previousGroupedData;
            var currentGroupIndex = cellData.groupIndex;
            if (currentGroupIndex !== previousGroupIndex) {
                previousGroupedData.push({
                    dateTable: [],
                    isGroupedAllDayPanel: (0, _utils.getIsGroupedAllDayPanel)(!!cellData.allDay, isVerticalGrouping),
                    groupIndex: currentGroupIndex,
                    key: (0, _utils.getKeyByGroup)(currentGroupIndex, isVerticalGrouping)
                })
            }
            if (cellData.allDay) {
                previousGroupedData[previousGroupedData.length - 1].allDayPanel = cellData
            } else {
                previousGroupedData[previousGroupedData.length - 1].dateTable.push(cellData)
            }
            return {
                previousGroupIndex: currentGroupIndex,
                previousGroupedData: previousGroupedData
            }
        }), {
            previousGroupIndex: -1,
            previousGroupedData: []
        })
    };
    _proto.isTimeCellShouldBeHighlighted = function(today, viewOffset, _ref2, cellData) {
        var startViewDate = _ref2.startViewDate,
            realEndViewDate = _ref2.realEndViewDate,
            showCurrentTimeIndicator = _ref2.showCurrentTimeIndicator;
        if (!showCurrentTimeIndicator || today < startViewDate || today >= realEndViewDate) {
            return false
        }
        var realTodayTimeMs = this.getLocalDateTimeInMs(today);
        var _this$getHighlightedI = this.getHighlightedInterval(cellData),
            _this$getHighlightedI2 = _slicedToArray(_this$getHighlightedI, 2),
            startMs = _this$getHighlightedI2[0],
            endMs = _this$getHighlightedI2[1];
        return realTodayTimeMs >= startMs && realTodayTimeMs < endMs
    };
    _proto.getHighlightedInterval = function(_ref3) {
        var date = _ref3.date,
            index = _ref3.index,
            duration = _ref3.duration,
            isFirst = _ref3.isFirst,
            isLast = _ref3.isLast;
        var cellTimeMs = this.getLocalDateTimeInMs(date);
        var isEvenCell = index % 2 === 0;
        switch (true) {
            case isFirst || isLast && !isEvenCell:
                return [cellTimeMs, cellTimeMs + duration];
            case isEvenCell:
                return [cellTimeMs - duration, cellTimeMs + duration];
            default:
                return [cellTimeMs, cellTimeMs + 2 * duration]
        }
    };
    _proto.getLocalDateTimeInMs = function(date) {
        var dateUtcMs = date.getTime() - date.getTimezoneOffset() * toMs("minute");
        return (0, _math.shiftIntegerByModule)(dateUtcMs, toMs("day"))
    };
    _proto.isLastCellInGroup = function(completeViewDataMap, index) {
        if (index === completeViewDataMap.length - 1) {
            return true
        }
        var currentGroupIndex = completeViewDataMap[index][0].groupIndex;
        var _completeViewDataMap$ = completeViewDataMap[index + 1][0],
            nextGroupIndex = _completeViewDataMap$.groupIndex,
            nextAllDay = _completeViewDataMap$.allDay;
        return nextAllDay || nextGroupIndex !== currentGroupIndex
    };
    return TimePanelDataGenerator
}();
exports.TimePanelDataGenerator = TimePanelDataGenerator;
